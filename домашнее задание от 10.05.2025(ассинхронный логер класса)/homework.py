# В этом задании вам нужно будет реализовать кастомный асинхронный логгер для Python-программы. Логгер должен
# записывать информацию о событиях и действиях, происходящих в асинхронных методах вашего класса. Это задание поможет вам
# разобраться с особенностями асинхронного программирования в Python и его применением в реальных проектах.

# 1 Кастомный асинхронный логгер
# + Напишите собственный логгер, который будет поддерживать асинхронную работу с логированием
# + Логгер должен использовать асинхронные функции для записи логов в файл
# + Логгер должен работать с различными уровнями логирования (INFO, ERROR, DEBUG)%
# + Сообщения логирования должны содержать временную метку и информацию о вызывающем методе или функции
# + Логгер должен использовать асинхронный I/O для записи в файл (например, с использованием aiofiles)
# 2 Применение логгера к асинхронному классу
# + Создайте асинхронный класс, который будет моделировать работу с асинхронной очередью задач
# + Метод для добавления задач в очередь
# + Метод для извлечения задач из очереди с имитацией работы (например, с использованием asyncio.sleep)
# + Метод для завершения работы, когда очередь пустая
# + В каждом методе должны быть асинхронные логирования
# + Для добавления задачи — логирование информации о добавленной задач
# + Для извлечения задачи — логирование информации о текущем состоянии очереди%
# + Для завершения работы — логирование ошибки, если операция завершена с проблемами%
# 3 Асинхронная запись логов
# + Логгер должен асинхронно записывать информацию в файл.
# Для этого используйте библиотеку aiofiles
# + Имя файла должно быть уникальным (например, с добавлением текущей даты и времени).




import asyncio  #  для работы с асинхронным программированием
import aiofiles  #  для асинхронной работы с файлами
import datetime  #  для работы с датой и временем


class AsyncLogger:
    def __init__(self, log_file: str):
        # Конструктор класса, принимает имя файла для логирования
        timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")  # Получаем текущую дату и время в формате YYYYMMDD_HHMMSS
        self.log_file = f"{log_file}_{timestamp}.log"  # Создаем уникальное имя файла, добавляя временную метку

    async def log(self, level: str, message: str):
        # Асинхронный метод для записи логов
        timestamp = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")  # Форматируем текущую дату и время
        log_message = f"{timestamp} [{level}] {message}\n"  # Формируем сообщение лога с временной меткой и уровнем

        # Асинхронная запись в файл
        async with aiofiles.open(self.log_file, mode='a') as f:  # открываем файл в режиме добавления
            await f.write(log_message)  #  записываем сообщение в файл

    async def info(self, message: str):
        # Метод для записи информационного сообщения
        await self.log("INFO", message)  # вызываем общий метод log с уровнем "INFO"

    async def error(self, message: str):
        # Метод для записи сообщения об ошибке
        await self.log("ERROR", message)  # вызываем общий метод log с уровнем "ERROR"

    async def debug(self, message: str):        
        await self.log("DEBUG", message)  # вызываем общий метод log с уровнем "DEBUG"



class AsyncTaskQueue:
    def __init__(self):
        self.queue = asyncio.Queue()  
        self.logger = AsyncLogger("task_queue_log")  #  экземпляр логгера с именем файла "task_queue_log"

    async def add_task(self, task: str):
        # Асинхронный метод для добавления задачи в очередь
        await self.queue.put(task)  # Добавляем задачу в очередь
        await self.logger.info(f"Добавлена задача: {task}")  # Логируем информацию о добавлении задачи

    async def process_tasks(self):
        # Асинхронный метод для обработки задач из очереди
        while not self.queue.empty():  # Пока очередь не пуста
            task = await self.queue.get()  # Извлекаем задачу из очереди
            await self.logger.info(f"Извлечена задача: {task}")  # Логируем информацию о извлечении задачи
            
            # Имитация выполнения задачи
            await asyncio.sleep(2)  # Задержка 
            self.queue.task_done()  # Указываем, что задача выполнена

    async def shutdown(self):
        # Асинхронный метод для завершения работы очереди
        if self.queue.empty():  # Если очередь пуста
            await self.logger.error("Попытка завершения работы, когда очередь пуста.")  # Логируем сообщение об ошибке
        else:
            await self.logger.info("Завершение работы очереди.")  # Логируем информацию о завершении работы




async def main():
    task_queue = AsyncTaskQueue()  #  экземпляр класса AsyncTaskQueue

    # Добавляем задачи в очередь
    await task_queue.add_task("Задача 1")  
    await task_queue.add_task("Задача 2")  
    
   
    await task_queue.process_tasks()  #  обработка задач из очереди

    # Завершаем работу
    await task_queue.shutdown()  # метод завершения работы очереди

# Запуск программы
if __name__ == "__main__":

    asyncio.run(main())  

